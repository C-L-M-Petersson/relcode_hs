module QState.TwoPhoton
(   getEnergyRPA
,   getEnergyFin

,   getIROmegas

,   getMElement
,   getMElements

,   getCorrectedMElement
,   getCorrectedMElements
) where

import           Control.Monad.Extra

import           Data.Composition
import           Data.List                 (transpose)

import           Maths.HilbertSpace.Scalar
import           Maths.QuantumNumbers

import           QState
import           QState.Configure
import           QState.TwoPhoton.Internal
import           QState.TwoPhoton.RPAE


getEnergyRPA :: QNum -> QNum -> QState [Double]
getEnergyRPA = withCDictM.:energyRPA

getEnergyFin :: QNum -> QNum -> Int -> QState [Double]
getEnergyFin = withCDictM.:.energyFin


getIROmegas :: Int -> QState [Double]
getIROmegas = withCDictM . irOmegas


getMElement :: QNum -> QNum -> QNum -> QNum -> QNum -> Int -> QState [Scalar]
getMElement = withCDictM.:::mElement

getMElements :: [QNum] -> [QNum] -> [QNum] -> [QNum] ->  [QNum] -> Int
                                                            -> QState [Scalar]
getMElements kappas0 ns0 kappas1 kappas2 mJs eFinalIndex = map sum . transpose
    <$>sequence [ getMElement kappa0 n0 kappa1 kappa2 mJ eFinalIndex
                    | (kappa0,n0) <- zip kappas0 ns0, kappa1 <- kappas1
                                                    , kappa2 <- kappas2
                                                    , mJ     <- mJs
                                                    ]


getCorrectedMElement :: QNum -> QNum -> [QNum] -> QNum -> QNum -> Int
                                                            -> QState [Scalar]
getCorrectedMElement kappa0 n0 kappas1 kappa2 mJ eFinalIndex = ifM
                                                   (getReadOption "use2phRPAE")
        (map sum . transpose<$>sequence [mElemBase,mElemCorr 0,mElemCorr 2])
        mElemBase
        --((liftIO.print=<<mElemBase)>>mElemBase)
--getCorrectedMElement kappa0 n0 kappas1 kappa2 mJ eFinalIndex = ifM
--                                                   (getReadOption "use2phRPAE")
--        (map sum . transpose<$>sequence [mElemBase,mElemCorr 0,mElemCorr 2])
--        mElemBase
--        --((liftIO.print=<<mElemBase)>>mElemBase)
    where mElemBase      = getMElements         [kappa0] [n0]
                                                 kappas1
                                                [kappa2]
                                                [mJ]   eFinalIndex
          mElemCorr jTot = getMElementCorrection kappa0 n0
                                                 kappa2
                                                 mJ  2 eFinalIndex

getCorrectedMElements :: [QNum] -> [QNum] -> [QNum] -> [QNum]
                                            -> [QNum] -> Int -> QState [Scalar]
getCorrectedMElements kappas0 ns0 kappas1 kappas2 mJs eFinalIndex =
    map sum . transpose<$>sequence
            [ getCorrectedMElement kappa0 n0 [] kappa2 mJ eFinalIndex
                        | (kappa0,n0) <- zip kappas0 ns0, kappa2 <- kappas2
                                                        , mJ     <- mJs
                                                        ]
